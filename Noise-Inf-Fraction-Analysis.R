### Scripts to analyze The effect of noise and informative experiment fraction on detection of correlated groups.
###by Luis F. Montano-Gutierrez. University of Edinburgh 2015

generateCovaryingGroups<-function(nrows, ncols, indexSize= 425, numPosSets=5, numelQuery=12, jitter.amt=.01, fraction.of.variables=1){
###this function generates a toy table of rows nrows and columns ncols, in which numPosSets groups of numelQuery
###observations show intragroup correlation in round(fraction.of.variables*ncols) experiments . if jitter.amt is 0, all members in each group are identical to each other.
#large numbers of jitter can cause the observations to become uncorrelated.
indexList= sample(nrows, indexSize, replace=F)
toyDataset<-matrix(nrow= nrows, ncol=ncols, data=rnorm(nrows*ncols))
reference<-indexList[numelQuery*numPosSets+1:length(indexList)]

indexNames<- rep(NA, indexSize)
indexNames[numelQuery*numPosSets+1:indexSize]<- 'REF'

if (fraction.of.variables==1){

colsample<- 1:ncols
}else{

colsample<-sample(1:ncols, round(fraction.of.variables*ncols))
}


for (i in 1:numPosSets){

centroid=toyDataset[indexList[(i-1)*numelQuery+1],]
for( j in 1: numelQuery){
indexNames[(i-1)*numelQuery+j]<- paste(LETTERS[i], j, sep='')
#cat('indexNames in ', (i-1)*numelQuery+j, 'should be ', paste(LETTERS[i], j, collapse= NULL), "\n")

#indexList[(i-1)*numelQuery+j]
toyDataset[indexList[(i-1)*numelQuery+j], colsample]<- centroid[colsample]

}

}
#Now we add noise
toyDataset<-jitter(toyDataset, amount=jitter.amt)

#cat(length(indexList), length(indexNames))
return(list(DATA=toyDataset, INDEX.LIST=indexList, INDEX.NAMES= indexNames, IMPORTANT.VARS=colsample))

}

indicestoTF<-function(indices, proteingroups){

out<- rep(NA, nrow(proteingroups))
out[indices]<-'T'
return(out)
}

##This function performs random forests on a table generated by generateCovaryingGroups.
computeRFofIndices<-function(dataset, indexList, numPosSets=5, numelQuery=12, specialVarSubset=NA){
centroids<- indexList[1:numelQuery*numPosSets]
reference<-indexList[numelQuery*numPosSets+1:length(indexList)]
referenceIndices<- indicestoTF(reference, dataset)
#cat(referenceIndices)
centroidIndices<-list()

forests<-list()


cors<- rep(NA, numPosSets)


for (i in 1:numPosSets){

#cat('round ', i, ': Numbers retrieved', indexList[((i-1)*numelQuery+1):(numelQuery*i)], "\n indexList indices: ", ((i-1)*numelQuery+1):(numelQuery*i), "\n example 1:\n", dataset[indexList[(i-1)*numelQuery+1], ], "\n example 2\n"  ,  dataset[indexList[(i-1)*numelQuery+2], ],"\n")
centroidIndices[[i]]<- indicestoTF(indexList[((i-1)*numelQuery+1):(numelQuery*i)], dataset)
#cat(centroidIndices[[i]], "\n\n")
tf<-merge.vectors(positive=centroidIndices[[i]], negative=referenceIndices)
#cat(table(tf))


cmat<- cor(t(dataset[indexList[((i-1)*numelQuery+1):(numelQuery*i)],]))

inds<-which(lower.tri(cmat), arr.ind=T)
cors[i]<- mean(cmat[inds])


forests[[i]]<-rf.workflow(cbind(tf, as.data.frame(dataset)))

}
cat('Special variable indices are ', specialVarSubset)
if(is.na(specialVarSubset)==FALSE && length(specialVarSubset)<ncol(dataset)){
specialVarForest<-rf.workflow(cbind(tf, as.data.frame(dataset[, specialVarSubset])))
nonSpecialVarForest<-rf.workflow(cbind(tf, as.data.frame(dataset[, -specialVarSubset])))
special2nonspecial.ratio= mean(specialVarForest$PREDICTORS.SCORES[indexList[((numPosSets-1)*numelQuery+1):(numelQuery*numPosSets)], "T"], na.rm=T)/mean(nonSpecialVarForest$PREDICTORS.SCORES[indexList[((numPosSets-1)*numelQuery+1):(numelQuery*numPosSets)], "T"], na.rm=T)
}else{
special2nonspecial.ratio=NA
}

all.rf.scores<- rep(NA, numPosSets)
all.separation.qualities <- rep(NA, numPosSets)

for (i in numPosSets){

#cat(forests[[i]]$PREDICTORS.SCORES[indexList[((i-1)*numelQuery+1):(numelQuery*i)], "T"])
all.rf.scores[i]<- mean(forests[[i]]$PREDICTORS.SCORES[indexList[((i-1)*numelQuery+1):(numelQuery*i)], "T"], na.rm=T)
all.separation.qualities[i]<- forests[[i]]$MAX.MCC


}

#cat(all.rf.scores)

outm<- c(mean(all.rf.scores, na.rm=T), mean(all.separation.qualities, na.rm=T), mean(cors, na.rm=T), special2nonspecial.ratio)
names(outm)<- c('RF.Score.Mean', 'MAX.MCC.Mean', 'COR.Mean', 'Ratio.Important.vs.unimportant' )

return(outm)

}

rfs<- computeRFofIndices(dataset=x$DATA, indexList=x$INDEX.LIST, numPosSets=num.pos.sets, numelQuery=numel.query)
 

###This function wraps both of the above functions to detect correlated groups by mean correlation, RF and MCC.
toy.RF.analysis<- function(nrow, ncol, log.jitter.range= c(-4,4) , index.size= 425, num.pos.sets=5, numel.query=12){
#steps is the total number of fractions of informative experiments to loop over.
steps=10
c<-1
out<-list()
out$RF<- rep(NA, steps)
out$MAX.MCC<-rep(NA, steps)
out$COR<-rep(NA,steps)

jitter.values<-seq(from=log.jitter.range[1], to=log.jitter.range[2],  length.out=steps)
cat ("length of jitter values: ", length(jitter.values), "\n")
for( i in jitter.values){
x<-generateCovaryingGroups(nrows=nrow, ncols=ncol, indexSize= index.size, numPosSets=num.pos.sets, numelQuery=numel.query, jitter.amt=exp(i))

rfs<- computeRFofIndices(dataset=x$DATA, indexList=x$INDEX.LIST, numPosSets=num.pos.sets, numelQuery=numel.query)
 
#task 1: covariance as a function of noise
#task 2: RF score as a funtion of noise
#task 3:separation quality as a function of noise

 out$RF[c]<- rfs['RF.Score.Mean']
 out$MAX.MCC[c]<- rfs['MAX.MCC.Mean']
 out$COR[c]<- rfs['COR.Mean']
 c<-c+1
 }
 
# plot(x=exp(jitter.values), y=out$RF, col="red")
# par(new=T)
# plot(x=exp(jitter.values), y=out$MAX.MCC, col="red")
# par(new=T)
#plot(x=exp(jitter.values), y=out$COR, col="red")
 
 return(out)
 
 }
 
 
 #This line generates the fraction analysis
 y<-toy.RF.analysis(nrow=nrow(protein.groups[,experiment.ratio.column.indices]), ncol=ncol(protein.groups[experiment.ratio.column.indices]), log.jitter.range= c(-4,4) , index.size= 425, num.pos.sets=5, numel.query=12)


##This function wraps all the above and creates matrices to show all how the group detecion measures change
###for one level of noise and fraction of informative experiments
fracAnalysis<- function(dataset.to.mimic, times=10, fractions=10, repeats=10, jitt=0, num.of.exp=dim(dataset.to.mimic)[2]){
fractionAnalysis=list()

fractionAnalysis$RFscore<-matrix(nrow=fractions, ncol=repeats, data=NA)
fractionAnalysis$MAXMCC<-matrix(nrow=fractions, ncol=repeats, data=NA)
fractionAnalysis$COR<-matrix(nrow=fractions, ncol=repeats, data=NA)
fractionAnalysis$RATIO.IMP.VS.NIMP<-matrix(nrow=fractions, ncol=repeats, data=NA)
for(i in 1:fractions){
for(j in 1:repeats){
x<-generateCovaryingGroups(dim(dataset.to.mimic)[1], num.of.exp, jitter.amt=jitt, fraction.of.variables=i/fractions)
rfOfIndices<- computeRFofIndices(dataset=x$DATA, indexList=x$INDEX.LIST, specialVarSubset=x$IMPORTANT.VARS)
fractionAnalysis$RFscore[i,j]<- rfOfIndices[1]
fractionAnalysis$MAXMCC[i,j]<- rfOfIndices[2]
fractionAnalysis$COR[i,j]<- rfOfIndices[3]
fractionAnalysis$RATIO.IMP.VS.NIMP[i,j]<- rfOfIndices[4]
}
}

fractionAnalysis$JITTER<-jitt
fractionAnalysis$NUMBER.OF.EXPERIMENTS<-num.of.exp

return(fractionAnalysis)
}

 d<-fracAnalysis(dataset.to.mimic=protein.groups[,experiment.ratio.column.indices], num.of.exp=20, repeats=2, fractions=2)
 
 
 finalfractAnalysis2<- list()
ji<-seq(0.01, 2, .05)
for(i in 1:length(ji)){
finalfractAnalysis[[i]]<-fracAnalysis(dataset.to.mimic=protein.groups[,experiment.ratio.column.indices], num.of.exp=20, repeats=3, jitt=ji[i], fractions=10)
save.image()
}

##this function summarizes all the information in the final fraction analysis by plotting how each measure changes as the informative experiment fraction (x axis) and the noise (y axis) change.
plot.fraction.analysis<-function(fa){
RF.Xfraction.Yjitter<- matrix(nrow= length(ji), ncol=nrow(fa[[1]]$RFscore), data=NA)
COR.Xfraction.Yjitter<- matrix(nrow= length(ji), ncol=nrow(fa[[1]]$RFscore), data=NA)
Ratio.Xfraction.Yjitter<- matrix(nrow= length(ji), ncol=nrow(fa[[1]]$RFscore), data=NA)
MCC.Xfraction.Yjitter<- matrix(nrow= length(ji), ncol=nrow(fa[[1]]$RFscore), data=NA)


noise.magnitude= rep(NA, length(fa))



for(i in 1: length(fa)){
 RF.Xfraction.Yjitter[i,]=apply(fa[[i]]$RFscore, 1, mean)
 MCC.Xfraction.Yjitter[i,]=apply(fa[[i]]$MAXMCC, 1, mean)
 COR.Xfraction.Yjitter[i,]=apply(fa[[i]]$COR, 1, mean)
 Ratio.Xfraction.Yjitter[i,]= apply(fa[[i]]$RATIO.IMP.VS.NIMP, 1, mean)
 noise.magnitude[i]<- fa[[i]]$JITTER
}
return(list(RATIO=Ratio.Xfraction.Yjitter, MCC=MCC.Xfraction.Yjitter, COR=COR.Xfraction.Yjitter, RF= RF.Xfraction.Yjitter))
}
#print(rbind(seq(0, 1, (1/length(fa))*4), noise.magnitude))

#pdf("RF_Xfraction_Yjitter_plot.pdf")

# image(t(RF.Xfraction.Yjitter), yaxt="n", xlab= "Fraction of informative data sets", ylab= "Noise amount", col=black2grey2yellow(20), main="Mean random forest score of positive set" )
# #axis(2, at= seq(0, 1, (1/length(fa))*4), labels=noise.magnitude[seq(1, length(noise.magnitude)+1, 4)], las=1 )
# dev.off()
# 
# pdf("MCC_Xfraction_Yjitter_plot.pdf")
# 
# image(t(MCC.Xfraction.Yjitter), yaxt="n", xlab= "Fraction of informative data sets", col=black2grey2yellow(20), ylab= "Noise amount", main="Maximum separation quality" )
# #axis(2, at= seq(0, 1, (1/length(fa))*4), labels=noise.magnitude[seq(1, length(noise.magnitude)+1, 4)], las=1 )
# dev.off()
# 
# pdf("COR_Xfraction_Yjitter_plot.pdf")
# 
# image(t(COR.Xfraction.Yjitter), yaxt="n", xlab= "Fraction of informative data sets", ylab= "Noise amount",col=black2grey2yellow(20), main=" mean correlation among positive set elements")
# #axis(2, at= seq(0, 1, (1/length(fa))*4), labels=noise.magnitude[seq(1, length(noise.magnitude)+1, 4)], las=1 )
# dev.off()
# 
# 
# pdf("Ratio_Xfraction_Yjitter_plot.pdf")
# 
# image(t(Ratio.Xfraction.Yjitter), yaxt="n", xlab= "Fraction of informative data sets",col=black2grey2yellow(20), ylab= "Noise amount", )
# #axis(2, at= seq(0, 1, (1/length(fa))*4), labels=noise.magnitude[seq(1, length(noise.magnitude)+1, 4)], las=1 )
# dev.off()
# image(t(Ratio.Xfraction.Yjitter), xlab= "Fraction of informative data sets", col=black2grey2yellow(20), ylab= "Noise amount", )
# 
# #axis(2, at= seq((1/length(fa)*10),1,(1/length(fa)*10))-(1/length(fa))) , labels=noise.magnitude[seq(1, length(noise.magnitude)+1, 4)], las=1 )

}

 kim<-plot.fraction.analysis(finalfractAnalysis)



 

 
